global function GamemodeGG_Init

void function GamemodeGG_Init()
{
	SetSpawnpointGamemodeOverride( FFA )

	SetShouldUseRoundWinningKillReplay( true )
	ClassicMP_ForceDisableEpilogue( true )
	SetLoadoutGracePeriodEnabled( false ) // prevent modifying loadouts with grace period
	SetWeaponDropsEnabled( false )
	Riff_ForceTitanAvailability( eTitanAvailability.Never )
	Riff_ForceBoostAvailability( eBoostAvailability.Disabled )

	AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	AddCallback_OnPlayerKilled( OnPlayerKilled )

	AddCallback_GameStateEnter( eGameState.WinnerDetermined, OnWinnerDetermined )

	AddCallback_GGEarnMeterFull( OnGGEarnMeterFilled )

	// set scorelimit if it's wrong, sort of a jank way to do it but best i've got rn
	try
	{
		if ( GetCurrentPlaylistVarInt( "scorelimit", GetGunGameWeapons().len() ) != GetGunGameWeapons().len() )
			SetPlaylistVarOverride( "scorelimit", GetGunGameWeapons().len().tostring() )
	}
	catch ( ex ) {}
}

void function OnPlayerRespawned( entity player )
{
	UpdateLoadout( player )
	thread OnPlayerRespawned_Threaded( player )
}

void function OnPlayerRespawned_Threaded( entity player )
{
	// bit of a hack, need to rework earnmeter code to have better support for completely disabling it
	// rn though this just waits for earnmeter code to set the mode before we set it back
	WaitFrame()
	if ( IsValid( player ) )
		PlayerEarnMeter_SetMode( player, eEarnMeterMode.DISABLED )
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
	if ( !victim.IsPlayer() || !attacker.IsPlayer() || GetGameState() != eGameState.Playing )
		return

	if ( attacker == victim ) // suicide
	{
		foreach ( entity player in GetPlayerArray() )
			
			Remote_CallFunction_NonReplay( player, "ServerCallback_GGGeneric", victim.GetEncodedEHandle(), 0)


		DeRank( victim )
	}
	else
	{
		if ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) != eDamageSourceId.melee_pilot_emptyhanded )
		{
			float percentageReward = GetCurrentPlaylistVarFloat( "gg_kill_reward", 1.0 )
			string scoreEvent = "KillPilot"

			if ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) == eDamageSourceId.human_execution )
			{
				string message = victim.GetPlayerName() + " got executed."
				foreach ( entity player in GetPlayerArray() )
					if ( player.GetTeam() != victim.GetTeam() )
					{
						Remote_CallFunction_NonReplay( player, "ServerCallback_GGGeneric", victim.GetEncodedEHandle(), 1)
					}

				DeRank( victim )

				percentageReward = GetCurrentPlaylistVarFloat( "gg_execution_reward", 1.0 )
				scoreEvent = "Execution"
			}

			Reward( attacker, victim, scoreEvent, percentageReward )
		}
	}

	table<int, bool> alreadyAssisted
	foreach( DamageHistoryStruct attackerInfo in victim.e.recentDamageHistory )
	{
		if( attackerInfo.attacker != attacker && !alreadyAssisted[attackerInfo.attacker.GetEncodedEHandle()] )
		{
			if ( attackerInfo.damageSourceId != eDamageSourceId.melee_pilot_emptyhanded ) { // makes sure that we don't give assists for melees, not strictly necessary for vanilla, but if mods change melee dmg it could be useful
				alreadyAssisted[attackerInfo.attacker.GetEncodedEHandle()] <- true
				
				if (attackerInfo.attacker.GetTeam() == attacker.GetTeam())
					Reward( attackerInfo.attacker, victim, "PilotAssist", 0 ) // dont give extra meter to the team for a teammate assisting the kill
				else
					Reward( attackerInfo.attacker, victim, "PilotAssist", GetCurrentPlaylistVarFloat( "gg_assist_reward", 0.0 ) )
			}
		}
	}
}

void function Reward( entity player, entity victim, string scoreEvent, float percentageReward )
{
	percentageReward = clamp(percentageReward, 0.0, 1.0)
	Sv_GGEarnMeter_AddPercentage( player, percentageReward )
	Remote_CallFunction_NonReplay( player, "ServerCallback_ScoreEvent", GetScoreEvent(scoreEvent).eventId, 0, eEventDisplayType.MEDAL, victim.GetEncodedEHandle(), 0.0, percentageReward)
}

void function DeRank( entity player )
{
	foreach ( entity teamPlayer in GetPlayerArrayOfTeam( player.GetTeam() ) )
	{
		Sv_GGEarnMeter_SetPercentage( teamPlayer, 0.0 ) // set earn meter bar for all members of team
	}

	SendDerankAnnouncementToTeam( player )
	
	if ( GameRules_GetTeamScore( player.GetTeam() ) != 0 )
	{
		AddTeamScore( player.GetTeam(), -1 ) // get absolutely fucking destroyed lol
		player.AddToPlayerGameStat( PGS_ASSAULT_SCORE, -1 )
		UpdateLoadoutForTeam( player )
	}
}

bool function OnGGEarnMeterFilled( entity player )
{
	AddTeamScore( player.GetTeam(), 1 )
	player.AddToPlayerGameStat( PGS_ASSAULT_SCORE, 1 )
	UpdateLoadout( player )
	SendRankUpAnnouncementToTeam( player )

	int currentScore = GameRules_GetTeamScore( player.GetTeam() )
	int maxScore = GetGunGameWeapons().len()

	return currentScore >= maxScore
}

void function UpdateLoadoutForTeam( entity player ) // calls UpdateLoadout on every member of the same team as the player
{
	foreach ( entity teamPlayer in GetPlayerArrayOfTeam( player.GetTeam() ) )
	{
		UpdateLoadout( teamPlayer )
	}
}

void function SendDerankAnnouncementToTeam( entity player )
{
	foreach ( entity teamPlayer in GetPlayerArrayOfTeam( player.GetTeam() ) )
	{
		// currently useless, but im keeping it here in case we want to send unique messages to the player and their team
		// this is now being handled in cl_gamemode_gg, still keeping it here though in case we want to split it into 2 remote functions at some point
		if ( teamPlayer == player ) 
		{
			Remote_CallFunction_NonReplay( teamPlayer, "ServerCallback_GGDemotion", player.GetEncodedEHandle() )
		}
		else
		{
			Remote_CallFunction_NonReplay( teamPlayer, "ServerCallback_GGDemotion", player.GetEncodedEHandle() )
		}
	}
}

void function SendRankUpAnnouncementToTeam( entity player )
{
	foreach ( entity teamPlayer in GetPlayerArrayOfTeam( player.GetTeam() ) )
	{
		if ( teamPlayer == player )
		{
			Remote_CallFunction_NonReplay( teamPlayer, "ServerCallback_GGPromotion", player.GetEncodedEHandle() )
		}
		else
		{		
			Remote_CallFunction_NonReplay( teamPlayer, "ServerCallback_GGPromotion", player.GetEncodedEHandle() )
		}
	}
}

void function UpdateLoadout( entity player )
{
	// todo: honestly, this should be reworked to use PilotLoadoutDefs instead of directly modifying weapons and shit

	int currentWeaponIndex = GameRules_GetTeamScore( player.GetTeam() )
	array<GunGameWeapon> weapons = GetGunGameWeapons()

	if ( currentWeaponIndex >= weapons.len() )
		currentWeaponIndex = weapons.len() - 1

	if ( currentWeaponIndex > 18 ) // play end of game music for special weapons
		PlayMusicToAll( eMusicPieceID.LEVEL_LAST_MINUTE ) // this *shouldn't* overlap if done multiple times

	GunGameWeapon weapon = weapons[ currentWeaponIndex ]

	foreach ( entity weapon in player.GetMainWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	foreach ( entity weapon in player.GetOffhandWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	if ( weapon.offhandSlot != -1 )
	{
		player.GiveOffhandWeapon( weapon.weapon, weapon.offhandSlot, weapon.mods )

		player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, [ "allow_as_primary" ] )
		player.SetActiveWeaponByName( "melee_pilot_emptyhanded" ) // Let the player use the melee in the primary slot, and then force equip it. Effectively gives them an empty hand.
	}
	else
	{
		player.GiveWeapon( weapon.weapon, weapon.mods )

		player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE )
	}

	if ( currentWeaponIndex == weapons.len() - 1 )
	{
		Sv_GGEarnMeter_SetFinalIcon( player )

		return
	}

	GunGameWeapon nextWeapon = weapons[ currentWeaponIndex + 1 ]
	Sv_GGEarnMeter_SetWeaponIcon( player, nextWeapon.weapon )
}

void function OnWinnerDetermined()
{
	SetRespawnsEnabled( false )
	SetKillcamsEnabled( false )
}