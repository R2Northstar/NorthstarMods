untyped

global function MessageUtils_Init

#if SERVER
global function NSSendLargeMessageToPlayer
global function NSSendInfoMessageToPlayer
global function NSSendPopUpMessageToPlayer
global function NSSendAnnouncementMessageToPlayer

global function NSCreateStatusMessageOnPlayer
global function NSEditStatusMessageOnPlayer
global function NSDeleteStatusMessageOnPlayer
#endif


#if CLIENT
global function ServerCallback_CreateServerHUDMessage
#endif



global struct genericServerHUDMessageStruct
{
	string title        = ""
	string description  = ""
	string image        = ""
	float duration      = 0
	vector color		= <0,0,0>
	int priority		= 0
	int style			= 0
}

enum eMessageType
{
	LARGE,
	INFO,
	POPUP,
	ANNOUNCEMENT,
	CREATE_STATUS,
	EDIT_STATUS,
	DELETE_STATUS
}

const int STATUS_MESSAGES_MAX = 4

#if CLIENT
genericServerHUDMessageStruct ServerMessage
array< genericServerHUDMessageStruct > popupMessageList
array< genericServerHUDMessageStruct > infoMessageList
array< genericServerHUDMessageStruct > largeMessageList
// table< id, rui >
table< string, var > statusMessageTable
array< AnnouncementData > announcementMessageList
#endif // CLIENT


void function MessageUtils_Init ()
{
#if CLIENT
	AddServerToClientStringCommandCallback( "ServerHUDMessageSetTitle", ServerCallback_SetServerHUDMessageTitle )
	AddServerToClientStringCommandCallback( "ServerHUDMessageSetDescription", ServerCallback_SetServerHUDMessageDescription )
	AddServerToClientStringCommandCallback( "ServerHUDMessageSetImage", ServerCallback_SetServerHUDMessageImage )
	AddServerToClientStringCommandCallback( "ServerHUDMessageRequest", ServerCallback_CreateServerHUDMessage )
	
	thread AnnouncementMessageHandler_Threaded()
	thread PopUpMessageHandler_Threaded()
	thread InfoMessageHandler_Threaded()
	thread LargeMessageHandler_Threaded()
#endif // CLIENT
}


#if SERVER
string function NSCreateStatusMessageOnPlayer( entity player, genericServerHUDMessageStruct message )
{
	string id = UniqueString( "StatusMessage_" )
	
	ServerToClientStringCommand( player, "ServerHUDMessageSetTitle " + message.title )
	ServerToClientStringCommand( player, "ServerHUDMessageSetDescription " + message.description )

	ServerToClientStringCommand( player, "ServerHUDMessageRequest " + eMessageType.CREATE_STATUS + " " + message.duration + " " + id )
	
	return id
}

void function NSEditStatusMessageOnPlayer( entity player, genericServerHUDMessageStruct message, string id  )
{
	ServerToClientStringCommand( player, "ServerHUDMessageSetTitle " + message.title )
	ServerToClientStringCommand( player, "ServerHUDMessageSetDescription " + message.description )
	
	ServerToClientStringCommand( player, "ServerHUDMessageRequest " + eMessageType.EDIT_STATUS + " " + message.duration + " " + id )
}

void function NSDeleteStatusMessageOnPlayer( entity player, string id  )
{
	ServerToClientStringCommand( player, "ServerHUDMessageRequest " + eMessageType.DELETE_STATUS + " " + 0 + " " + id )
}


void function NSSendAnnouncementMessageToPlayer( entity player, genericServerHUDMessageStruct message )
{
	ServerToClientStringCommand( player, "ServerHUDMessageSetTitle " + message.title )
	ServerToClientStringCommand( player, "ServerHUDMessageSetDescription " + message.description )

	ServerToClientStringCommand( player, "ServerHUDMessageRequest " + eMessageType.ANNOUNCEMENT + " " + message.duration + " " + message.color.x + " " + message.color.y + " " + message.color.z + " " + message.priority + " " + message.style )
}

void function NSSendPopUpMessageToPlayer( entity player, genericServerHUDMessageStruct message )
{
	ServerToClientStringCommand( player, "ServerHUDMessageSetDescription " + message.description )

	ServerToClientStringCommand( player, "ServerHUDMessageRequest " + eMessageType.POPUP + " " + message.duration )
}

void function NSSendLargeMessageToPlayer( entity player, genericServerHUDMessageStruct message )
{
	ServerToClientStringCommand( player, "ServerHUDMessageSetTitle " + message.title )
	ServerToClientStringCommand( player, "ServerHUDMessageSetDescription " + message.description )
	ServerToClientStringCommand( player, "ServerHUDMessageSetImage " + message.image )

	ServerToClientStringCommand( player, "ServerHUDMessageRequest " + eMessageType.LARGE + " " + message.duration )
}

void function NSSendInfoMessageToPlayer( entity player, genericServerHUDMessageStruct message )
{
	ServerToClientStringCommand( player, "ServerHUDMessageSetDescription " + message.description )

	ServerToClientStringCommand( player, "ServerHUDMessageRequest " + eMessageType.INFO + " " + message.duration )
}
#endif // SERVER


#if CLIENT
void function ServerCallback_SetServerHUDMessageTitle ( array< string > args  )
{
	string title
	foreach( string arg in args )
		title += arg + " "

	ServerMessage.title = title
}

void function ServerCallback_SetServerHUDMessageDescription ( array< string > args  )
{
	string desc
	foreach( string arg in args )
		desc += arg + " "
	
	desc = EscapeString( desc )
	
	ServerMessage.description = desc
}

void function ServerCallback_SetServerHUDMessageImage ( array< string > args  )
{
	string image
	foreach( string arg in args )
		image += arg

	ServerMessage.image = image
}

void function ServerCallback_CreateServerHUDMessage ( array< string > args  )
{
	ServerMessage.duration = args[1].tofloat()
	if( args.len() == 7 ) // Announcement
	{
		ServerMessage.color = Vector( args[2].tofloat(), args[3].tofloat(), args[4].tofloat() )
		ServerMessage.priority = args[5].tointeger()
		ServerMessage.style = args[6].tointeger()
	}

	switch ( args[0].tointeger() )
	{
		case eMessageType.LARGE:
			ShowLargeMessage()
			break
		case eMessageType.INFO:
			ShowInfoMessage()
			break
		case eMessageType.POPUP:
			ShowPopUpMessage()
			break
		case eMessageType.ANNOUNCEMENT:
			ShowAnnouncementMessage()
			break
		case eMessageType.CREATE_STATUS:
			CreateStatusMessage( args[2] )
			break
		case eMessageType.EDIT_STATUS:
			EditStatusMessage( args[2] )
			break
		case eMessageType.DELETE_STATUS:
			thread DeleteStatusMessage( args[2] )
			break
		default:
			return
	}
	
	/*
		var rui = CreatePermanentCockpitRui( $"ui/wave_announcement.rpak", 1 )
		var rui = CreateCockpitRui(  $"ui/announcement_results.rpak" )
		var rui = CreateCockpitRui( $"ui/callsign_basic.rpak" )
		var rui = CreatePermanentCockpitRui( $"ui/hint_display.rpak" )
		var rui = CreateCockpitRui( $"ui/cockpit_console_text_top_left.rpak", 0 )
		var rui = CreatePermanentCockpitRui( $"ui/at_wave_intro.rpak" )
 	*/
}

void function DeleteStatusMessage( string id )
{
	if ( id in statusMessageTable )
	{
		var rui = statusMessageTable[ id ]
		RuiSetGameTime( rui, "startFadeOutTime", Time() )
		
		wait 0.6
		
		delete statusMessageTable[ id ]
		RuiDestroyIfAlive( rui )
		
		int i = 0
		foreach( _id, _rui in statusMessageTable )
		{
			RuiSetInt( _rui, "listPos", i )
			
			i++
		}
	}
}

void function EditStatusMessage( string id )
{
	if( id in statusMessageTable )
	{
		var rui = statusMessageTable[ id ]
		RuiSetString( rui, "titleText", ServerMessage.title )
		RuiSetString( rui, "itemText", ServerMessage.description )
	}
}

void function CreateStatusMessage( string id )
{
	// Cap at 4 messages at a time
	if( statusMessageTable.len() == STATUS_MESSAGES_MAX )
		return
	
	
	var rui = CreatePermanentCockpitRui( $"ui/at_wave_intro.rpak" )
	RuiSetInt( rui, "listPos", statusMessageTable.len() )
	RuiSetGameTime( rui, "startFadeInTime", Time() )
	RuiSetString( rui, "titleText", ServerMessage.title )
	RuiSetString( rui, "itemText", ServerMessage.description )
	RuiSetFloat2( rui, "offset", <0,-250,0> )
	
	statusMessageTable[ id ] <- rui
}

void function AnnouncementMessageHandler_Threaded()
{
	while( true )
	{
		while( announcementMessageList.len() == 0 )
			WaitFrame()

		AnnouncementFromClass( GetLocalViewPlayer(), announcementMessageList[0] )

		wait 5

		announcementMessageList.remove(0)
	}
}

void function ShowAnnouncementMessage()
{
	AnnouncementData announcement = Announcement_Create( ServerMessage.title )
	Announcement_SetSubText( announcement, ServerMessage.description )
	Announcement_SetTitleColor( announcement, ServerMessage.color )
	Announcement_SetPurge( announcement, true )
	Announcement_SetPriority( announcement, ServerMessage.priority )
	Announcement_SetSoundAlias( announcement, SFX_HUD_ANNOUNCE_QUICK )
	Announcement_SetStyle( announcement, ServerMessage.style )
	
	announcementMessageList.append( announcement )
}

void function PopUpMessageHandler_Threaded()
{
	while( true )
	{
		while( popupMessageList.len() == 0 )
			WaitFrame()

		var rui = CreateCockpitRui( $"ui/killdeath_info.rpak" )
		RuiSetGameTime( rui, "startTime", Time() )
		RuiSetFloat( rui, "duration", 20 ) // It has a weird end animation
		RuiSetString( rui, "messageText", popupMessageList[0].description )
		RuiSetBool( rui, "isBigText", true )

		wait 2.4

		popupMessageList.remove(0)
		RuiDestroyIfAlive( rui )
	}
}

void function ShowPopUpMessage()
{
	popupMessageList.append( clone ServerMessage )
}

void function LargeMessageHandler_Threaded()
{
	while( true )
	{
		while( largeMessageList.len() == 0 )
			WaitFrame()

		var rui = CreatePermanentCockpitRui( $"ui/fd_tutorial_tip.rpak" )
		RuiSetImage( rui, "backgroundImage", StringToAsset( largeMessageList[0].image ) )
		RuiSetString( rui, "titleText", largeMessageList[0].title )
		RuiSetString( rui, "descriptionText", largeMessageList[0].description )
		RuiSetGameTime( rui, "updateTime", Time() )
		RuiSetFloat( rui, "duration", largeMessageList[0].duration )

		wait largeMessageList[0].duration * 0.34

		largeMessageList.remove(0)
		RuiDestroyIfAlive( rui )
	}
}

void function ShowLargeMessage()
{
	largeMessageList.append( clone ServerMessage )
}

void function InfoMessageHandler_Threaded()
{
	while( true )
	{
		while( infoMessageList.len() == 0 )
			WaitFrame()

		var rui = CreatePermanentCockpitRui( $"ui/death_hint_mp.rpak" )
		RuiSetString( rui, "hintText", infoMessageList[0].description )
		RuiSetGameTime( rui, "startTime", Time() )
		RuiSetFloat3( rui, "bgColor", <0,0,0> )
		RuiSetFloat( rui, "bgAlpha", 0.5 )

		wait 7

		infoMessageList.remove(0)
		RuiDestroyIfAlive( rui )
	}
}

void function ShowInfoMessage()
{
	infoMessageList.append( clone ServerMessage )
}

#endif // CLIENT


string function EscapeString( string str )
{
	string unformattedMessage = str
	string message
	
	var start = 0
	var end = 0
	int i = 0
	bool first = true
	while ( true )
	{
		end = unformattedMessage.find( "\\n" )
		
		if( end == null )
			break
		
		message += unformattedMessage.slice( 0, end ) + "\n"
		first = false
		
		unformattedMessage = unformattedMessage.slice( end + 2, unformattedMessage.len() )
		
		start = end
		
		i++
		if( i == 30 )
			return "Failed to Escape string"
	}
	
	message += unformattedMessage.slice( 0, unformattedMessage.len() )
	
	return message
}